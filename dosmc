#! /bin/sh
eval '(exit $?0)' && eval 'PERL_BADLANG=x;PATH="$PATH:.";export PERL_BADLANG\
;exec perl -x -S -- "$0" ${1+"$@"};#'if 0;eval 'setenv PERL_BADLANG x\
;setenv PATH "$PATH":.;exec perl -x -S -- "$0" $argv:q;#'.q
#!perl -w
+push@INC,'.';$0=~/(.*)/s;do(index($1,"/")<0?"./$1":$1);die$@if$@__END__+if 0
;#Don't touch/remove lines 1--7: http://www.inf.bme.hu/~pts/Magic.Perl.Header
#
# dosmc: C compiler driver to produce tiny DOS .exe and .com executables
# by pts@fazekas.hu at Thu Jun 25 00:59:56 CEST 2020
#
# TODOs:
#
# !! Optimize away call in entry point of main and _start. This can be tricky and needs smart disassembly, for example in examples/m0f.c, code of _start and double_int overlap.
# !! Optimize away extra exit after _start.
# !! Optimize away `pop ...' registers at end of _start.
# !! Optimize `mov al, ...; mov ah, ...' at end of main and _start.
# !! Add option for word alignment of data segments, for speed.
# !! TODO(pts): Add automatic argv splitting for main, but keep using argc=0 and argv=NULL if -D_STUBARG_MAIN, and keep these unspecified if -D_NOARG_MAIN.
# !! Add disassembler to cld optimization (maybe_contains_8086_str).
# !! Add disassembler to check that ds is not used in the .exe file, and optimize away `pop ds'. (Without a disassembler, even if _CONST, _CONST2 and _DATA are empty, pointers to local (on-stack) variables may be taken and they won't work.)
# !! Optimize away everything if the first instruction by the entry point is `ret' or exit.
# !! Optimize away unused basic blocks from .text.
# !! Remove `push dx' and `pop dx' (and other register operations) from examples/hello.com.
# !! Recognize the entry point (implicit ..start) in MODEND.
#
# !! Cleanup flag to remove .tmp files.
# !! Allow .obj files from NASM, give source example for section.
# !! Allow .nasm source files, give source example for section.
# !! Allow .obj files from A86, give source example for section.
# !! Allow .obj files from WASM, give source example for section.
# !! Make simple_nasm_exe.nasm work (ds, ss, sp setup is unnecessary, remove that).
#

BEGIN { $^W = 1 }
use integer;
use strict;

my $MYDIR = $0;
die "$0: fatal: script directory not specified\n" if $MYDIR !~ s@/+[^/]+\Z(?!\n)@@;
die "$0: fatal: bad current directory: $MYDIR\n" if $MYDIR =~ m@:@;  # $ENV{PATH} separator. TODO(pts): Port to Win32.

if (!@ARGV or $ARGV[0] eq "-?" or $ARGV[0] eq "-h" or $ARGV[0] eq "--help") {
  die "$0: fatal: cannot redirect stdout\n" if !@ARGV and !open(STDOUT, ">&", \*STDERR);
  print "dosmc: C compiler driver to produce tiny DOS .exe and .com executables\n";
  print "This is free software, GNU GPL >=2.0. There is NO WARRANTY. Use at your risk.\n";
  print "Usage: $0 [<dosmc-flag> ...] [<wcc-flag> ...] <prog.c>\n";
  print "To compile DOS .exe, specify no flag. To compile DOS .com, specify -bt=com\n";
  print "See details on https://github.com/pts/dosmc\n";
  exit(@ARGV ? 0 : 1);
}

my $ARG = "";
my $EXT = "";
my $EXEOUT = "";
my $Q = "-q";
my $PL = "-ce";
my $CPUF = "-0";
my @sources;
my @wcc_cmd = ('wcc');
my @wcc_args;

for my $arg (@ARGV) {
  if ($arg eq "--" or $arg eq "-" or !length($arg)) {
    die "$0: fatal: unsupported argument: $arg\n";
  } elsif ($arg eq "-pl" or $arg eq "-zs" or $arg eq "-c" or $arg eq "-ce" or $arg eq "-cn" or $arg eq "-cw") {
    $PL = $arg;  # Do preprocessing (-pl), syntax check (-zs), compile to .obj (-c), emit exec without nasm (nonstandard) (-ce), emit exec with nasm (nonstandard) (-cw), compile to .wasm (nonstandard) (-cw).
  } elsif ($arg eq "-q") {
    $Q = $arg;  # Quiet. Default.
  } elsif ($arg eq "-nq") {
    $Q = "";  # Quiet. Default.
  } elsif ($arg eq "-bt=dos" or $arg eq "-bt=exe") {
    $EXT = "exe";  # Default.
  } elsif ($arg eq "-bt=com" or $arg eq "-mt") {
    $EXT = "com";  # Default.
  } elsif ($arg =~ m@\A-bt@) {
    die"$0: fatal: unsupported target: $arg\n";
  } elsif ($arg =~ m@\A-(?:fo|fe)=(.*)\Z(?!\n)@s) {
    $EXEOUT = $1;  # `wcc -fo=...' for object files; `wcl -fe=...' for executable files. For dosmc, it's final output file.
  } elsif ($arg eq "-ms") {
  } elsif ($arg =~ m@\A-m@) {
    die "$0: fatal: only -ms (small memory model) supported: $arg\n";
  } elsif ($arg =~ m@\A-[0-6]\Z(?!\n)@) {
    $CPUF = $arg;
  } elsif ($arg =~ m@\A-(?:b|zW|zw)@) {
    die "$0: fatal: unsupported Windows target: $arg\n";
  } elsif ($arg eq "-ecw") {  # We support only the Watcom default calling convention (and name mangling).
  } elsif ($arg =~ m@\A-ec@) {
    die "$0: fatal: unsupported default calling convention: $arg\n";
  } elsif ($arg =~ m@\A-@) {
    push @wcc_args, $arg;
  } elsif ($arg =~ m@[.]c\Z(?!\n)@) {
    push @sources, $arg;
  } else {
    die "$0: fatal: bad file extension for source file (must be .c): $arg\n";
  }
}
$EXT = $EXEOUT =~ m@[.](?:com|COM)\Z(?!\n)@ ? "com" : "exe" if !length($EXT);
die "$0: fatal: missing source file argument\n" if !@sources;
for my $src (@sources) {
  die "$0: fatal: source file not found: $src\n" if !-f($src);
}
die "$0: fatal: multiple source file arguments\n" if @sources > 1;  # TODO(pts): Relax this.

die "$0: fatal: missing executable $MYDIR/ow2bin/wcc; run $MYDIR/download_openwatcom.sh first\n" if !-x("$MYDIR/ow2bin/wcc");
delete $ENV{WATCOM};
delete $ENV{INCLUDE};
$ENV{PATH} = "/bin:/usr/bin" if !defined($ENV{PATH}) or !length($ENV{PATH});  # TODO(pts): Port to Win32.
$ENV{PATH} = "$MYDIR/ow2bin:$ENV{PATH}";  # TODO(pts): Port to Win32.

my $SRC = $sources[0];
my $SRCBASE = $SRC; $SRCBASE =~ s@[.][^./]+\Z(?!\n)@@s;  # TODO(pts): Port to Win32.
my $PLL = "";
if ($PL eq "-cn" or $PL eq "-ce") {
  # !! TODO(pts): Add -ca to produce .nasm output.
  $EXEOUT = "$SRCBASE.$EXT" if !length($EXEOUT);
  push @wcc_cmd, "-fo=$SRCBASE.tmp.obj";
} elsif ($PL eq "-cw") {
  $EXEOUT = "$SRCBASE.wasm" if !length($EXEOUT);
  push @wcc_cmd, "-fo=$SRCBASE.tmp.obj";
} else {
  if ($PL eq "-c") {
    $EXEOUT = "$SRCBASE.obj" if !length($EXEOUT);
  } else {
    $PLL = $PL;
  }
  push @wcc_cmd, "-fo=$EXEOUT" if length($EXEOUT);
}

# Quote string from Bourne-like shells.
# !! Port this to Win32.
sub shqe($) {
  return $_[0] if $_[0]=~/\A[-.\/\w][-.\/\w=]*\Z(?!\n)/;
  my $S=$_[0];
  $S=~s@'@'\\''@g;
  "'$S'"
}

sub print_command(@) {
  my $redirect = "";
  $redirect .= " >" . shqe(substr(pop(@_), 3)) if @_ and substr($_[-1], 0, 3) eq " > ";
  my $cmdstr = join(" ", map { shqe($_) } @_);
  select(STDOUT); $| = 1; print ": $cmdstr$redirect\n";
}

sub run_command(@) {
  print_command(@_) if !length($Q);
  if (substr($_[-1], 0, 3) eq " > ") {  # Redirect stdout.
    die "$0: assert: command too short\n" if @_ < 2;  # 2 for shell word splitting.
    my $fn = substr(pop(@_), 3);
    my $f;
    die "$0: fatal: cannot open for writing: redirect stdout\n" if !open($f, ">", $fn);
    my $old_stdoutf;
    die "$0: fatal: cannot redirect old stdout\n" if !open($old_stdoutf, ">&", \*STDOUT);
    die "$0: fatal: cannot redirect stdout\n" if !open(STDOUT, ">&", $f);
    close($f);
    my $status = system(@_);
    die "$0: fatal: cannot redirect back stdout\n" if !open(STDOUT, ">&", $old_stdoutf);
    close($old_stdoutf);
    $status
  } else {
    die "$0: assert: command too short\n" if @_ < 2;  # 2 for shell word splitting.
    system(@_)  # Returns 0 on success.
  }
}

# Corresponding `wcc: owcc' flags:
# -v: lack of -q
# -bdos: -bt=dos
# -ms: -mcomodel=s (default)
# -i=... : -I...
# -s: -fno-stack-check
# -os: -Os  TODO(pts): Should we do -om -oi -ol (from -ox) as well?
# -0: -march=i86
# -W: ??
# ??: -W
# -w4: -Wall
# -wx: -Wextra
# -we: -Werror
# -wcd=202: -Wcd=202 ??
# -D...: -D...
# (default to generate obj, do not link): -c
# -fo=...: -o ...
# -fr: ?? Set error filename.
# -pl: -E
# No need to set $WATCOM or to extend $PATH.
# 202: symbol defined but not referenced (useful for static functions).
push @wcc_cmd, "-D__DOSMC__";
push @wcc_cmd, "-D__DOSMC_COM__" if $EXT eq "com";
push @wcc_cmd, $Q if length($Q);
push @wcc_cmd, $PLL if length($PLL);
push @wcc_cmd, "-bt=dos", "-ms", "-i=$MYDIR", "-s", "-os", "-W", "-w4", "-wx", "-we", "-wcd=202", $CPUF, "-fr", @wcc_args, $SRC;
if (run_command(@wcc_cmd)) {
  print STDERR "$0: fatal: wcc failed\n"; exit(2);
}

# --- Linker: Reads .obj files, writes .exe and .com files (for equivalent .nasm files).

# Checks if the entry point contains an instructions to exit immediately,
# return exit code (0..255) if found, otherwise returns undef.
sub get_8086_exit_code($$) {
  my($ledatar, $symbol_ofsr) = @_;
  pos($ledatar->{_TEXT}) = defined($symbol_ofsr->{_start_}) ? $symbol_ofsr->{_start_} : $symbol_ofsr->{main_};
  return 0 if $ledatar->{_TEXT} =~ /\G(?:\x31\xC0)?\xC3/gcs;  # xor ax, ax;; ret
  $ledatar->{_TEXT} =~ /\G[\x06\x0E\x16\x1E\x50-\x57]+/gcs;  # Skip some register pushes.
  # TODO(pts): Add skipping of (sub sp, ...) for local variables.
  return unpack("C", $1) if
      $ledatar->{_TEXT} =~ /\G\xB8(.)\x4C\xCD\x21/gcs or  # mov ax, 0x4c??;; int 0x21
      $ledatar->{_TEXT} =~ /\G\xB4\x4C\xB0(.)\xCD\x21/gcs or  # mov ah, 0x4c;; mov al, 0x??;; int 0x21
      $ledatar->{_TEXT} =~ /\G\xB0(.)\xB4\x4C\xCD\x21/gcs or  # mov al, 0x??;; mov ah, 0x4c;; int 0x21
      $ledatar->{_TEXT} =~ /\G\xB8(.).\xC3/gcs or  # mov ax, 0x--??;; ret
      $ledatar->{_TEXT} =~ /\G\xB0(.)\xC3/gcs;  # mov al, 0x??;; ret
  undef
}

# Regexp matching 80286 instructions, including 80287, but excluding
# protected mode. Prefixes are considered separate instructions.
my $INST_80286_RE = q(\x26\x2E\x36\x3E\x9B\xF0\xF2\xF3]|[\x06\x07\x0E\x16\x17\x1E\x1F\x27\x2F\x37\x3F-\x61\x6C-\x6F\x90-\x99\x9C-\x9F\xA4-\xA7\xAA-\xAF\xC3\xC9\xCB\xCC\xCE\xCF\xD6\xD7\xEC-\xEF\xF1\xF4\xF5\xF8-\xFD]|[\x04\x0C\x14\x1C\x24\x2C\x34\x3C\x6A\x70-\x7F\xA8\xB0-\xB7\xCD\xD4\xD5\xE0-\xE7\xEB][\x00-\xFF]|[\x62\x8D\xC4\xC5\xDA][\x00-\x05\x07-\x0D\x0F-\x15\x17-\x1D\x1F-\x25\x27-\x2D\x2F-\x35\x37-\x3D\x3F]|[\x00-\x03\x08-\x0B\x10-\x13\x18-\x1B\x20-\x23\x28-\x2B\x30-\x33\x38-\x3B\x84-\x8C\x8E\xD8][\x00-\x05\x07-\x0D\x0F-\x15\x17-\x1D\x1F-\x25\x27-\x2D\x2F-\x35\x37-\x3D\x3F\xC0-\xFF]|\xDE[\x00-\x05\x07-\x0D\x0F-\x15\x17-\x1D\x1F-\x25\x27-\x2D\x2F-\x35\x37-\x3D\x3F\xC0-\xCF\xD9\xE0-\xFF]|\xDC[\x00-\x05\x07-\x0D\x0F-\x15\x17-\x1D\x1F-\x25\x27-\x2D\x2F-\x35\x37-\x3D\x3F\xC0-\xCF\xE0-\xFF]|\xFF[\x00-\x05\x07-\x0D\x0F-\x15\x17-\x1D\x1F-\x25\x27-\x2D\x2F-\x35\x37\xC0-\xD7\xE0-\xE7\xF0-\xF7]|[\xD0-\xD3][\x00-\x05\x07-\x0D\x0F-\x15\x17-\x1D\x1F-\x25\x27-\x2D\x2F\x38-\x3D\x3F\xC0-\xEF\xF8-\xFF]|\xFE[\x00-\x05\x07-\x0D\x0F\xC0-\xCF]|\xD9[\x00-\x05\x07\x10-\x15\x17-\x1D\x1F-\x25\x27-\x2D\x2F-\x35\x37-\x3D\x3F\xC0-\xD0\xE0\xE1\xE4\xE5\xE8-\xEE\xF0-\xF4\xF6-\xFA\xFC\xFD]|\xDF[\x00-\x05\x07\x10-\x15\x17-\x1D\x1F-\x25\x27-\x2D\x2F-\x35\x37-\x3D\x3F\xC0-\xC7\xE0]|\xDD[\x00-\x05\x07\x10-\x15\x17-\x1D\x1F-\x25\x27\x30-\x35\x37-\x3D\x3F\xC0-\xC7\xD0-\xDF]|\xDB[\x00-\x05\x07\x10-\x15\x17-\x1D\x1F\x28-\x2D\x2F\x38-\x3D\x3F\xE0-\xE3]|\x8F[\x00-\x05\x07\xC0-\xC7]|\x0F[\x0B\xFF]|[\xF6\xF7][\x10-\x15\x17-\x1D\x1F-\x25\x27-\x2D\x2F-\x35\x37-\x3D\x3F\xD0-\xFF]|[\x05\x0D\x15\x1D\x25\x2D\x35\x3D\x68\xA0-\xA3\xA9\xB8-\xBF\xC2\xCA\xE8\xE9][\x00-\xFF]{2}|[\x6B\x80\x83][\x00-\x05\x07-\x0D\x0F-\x15\x17-\x1D\x1F-\x25\x27-\x2D\x2F-\x35\x37-\x3D\x3F\xC0-\xFF][\x00-\xFF]|[\xC0\xC1][\x00-\x05\x07-\x0D\x0F-\x15\x17-\x1D\x1F-\x25\x27-\x2D\x2F\x38-\x3D\x3F\xC0-\xEF\xF8-\xFF][\x00-\xFF]|\xF6[\x00-\x05\x07\x50-\x7F\xC0-\xC7][\x00-\xFF]|\xC6[\x00-\x05\x07\xC0-\xC7][\x00-\xFF]|\x8F[\x40-\x47][\x00-\xFF]|\xFE[\x40-\x4F][\x00-\xFF]|\xFF[\x40-\x77][\x00-\xFF]|[\x00-\x03\x08-\x0B\x10-\x13\x18-\x1B\x20-\x23\x28-\x2B\x30-\x33\x38-\x3B\x62\x84-\x8E\xC4\xC5\xD8\xDA\xDC\xDE][\x40-\x7F][\x00-\xFF]|[\xD0-\xD3][\x40-\x6F\x78-\x7F][\x00-\xFF]|[\xD9\xDF][\x40-\x47\x50-\x7F][\x00-\xFF]|\xDD[\x40-\x47\x50-\x67\x70-\x7F][\x00-\xFF]|\xDB[\x40-\x47\x50-\x5F\x68-\x6F\x78-\x7F][\x00-\xFF]|\xF7[\x50-\x7F][\x00-\xFF]|\xC8[\x00-\xFF]{3}|[\x69\x81][\x00-\x05\x07-\x0D\x0F-\x15\x17-\x1D\x1F-\x25\x27-\x2D\x2F-\x35\x37-\x3D\x3F\xC0-\xFF][\x00-\xFF]{2}|\xF7[\x00-\x05\x07\x16\x1E\x26\x2E\x36\x3E\x90-\xC7][\x00-\xFF]{2}|\xC7[\x00-\x05\x07\xC0-\xC7][\x00-\xFF]{2}|[\x00-\x03\x08-\x0B\x10-\x13\x18-\x1B\x20-\x23\x28-\x2B\x30-\x33\x38-\x3B\x62\x84-\x8E\xC4\xC5\xD8\xDA\xDC\xDE][\x06\x0E\x16\x1E\x26\x2E\x36\x3E\x80-\xBF][\x00-\xFF]{2}|\xFF[\x06\x0E\x16\x1E\x26\x2E\x36\x80-\xB7][\x00-\xFF]{2}|[\xD0-\xD3][\x06\x0E\x16\x1E\x26\x2E\x3E\x80-\xAF\xB8-\xBF][\x00-\xFF]{2}|\xFE[\x06\x0E\x80-\x8F][\x00-\xFF]{2}|[\xD9\xDF][\x06\x16\x1E\x26\x2E\x36\x3E\x80-\x87\x90-\xBF][\x00-\xFF]{2}|\xDD[\x06\x16\x1E\x26\x36\x3E\x80-\x87\x90-\xA7\xB0-\xBF][\x00-\xFF]{2}|\xDB[\x06\x16\x1E\x2E\x3E\x80-\x87\x90-\x9F\xA8-\xAF\xB8-\xBF][\x00-\xFF]{2}|\x8F[\x06\x80-\x87][\x00-\xFF]{2}|\xF6[\x16\x1E\x26\x2E\x36\x3E\x40-\x47\x90-\xBF][\x00-\xFF]{2}|\xC6[\x40-\x47][\x00-\xFF]{2}|[\x6B\x80\x83][\x40-\x7F][\x00-\xFF]{2}|[\xC0\xC1][\x40-\x6F\x78-\x7F][\x00-\xFF]{2}|\x0F[\x78\x79][\x00-\xFF]{2}|[\x9A\xEA][\x00-\xFF]{4}|[\x6B\x80\x83][\x06\x0E\x16\x1E\x26\x2E\x36\x3E\x80-\xBF][\x00-\xFF]{3}|[\xC0\xC1][\x06\x0E\x16\x1E\x26\x2E\x3E\x80-\xAF\xB8-\xBF][\x00-\xFF]{3}|[\xC6\xF6][\x06\x80-\x87][\x00-\xFF]{3}|[\xC7\xF7][\x40-\x47][\x00-\xFF]{3}|[\x69\x81][\x40-\x7F][\x00-\xFF]{3}|\x0F[\x78\x79][\x00-\xFF]{3}|[\x69\x81][\x06\x0E\x16\x1E\x26\x2E\x36\x3E\x80-\xBF][\x00-\xFF]{4}|[\xC7\xF7][\x06\x80-\x87][\x00-\xFF]{4});
# Regexp maching a 8086 string instruction.
my $STR_INST_80286_RE = q([\x6C-\x6F\xA4-\xA7\xAA-\xAF]);

# Checks the following (for simplicity):
#
# * All relative relocations have a 0 base.
# * $data is a concatenation of 80286 instructions, including 80287
#   floating point instructions, but excluding protected mode
#   instructions. (We check that there are no unknown opcodes or
#   i386+-only opcodes.)
# * There are are no split offsets in the middle of an
#   instruction. Splits are at labels (@$symbolsr) and after relative
#   relocations.
# * There are no relative jump/call targets outside the range of $data
#   (jumping right after $data is OK).
# * There are no relative jump/call targets in the middle of an instruction.
#
# Returns "" for simple code without string instructions, 0 for simple code
# with string instructions, a message explaining the complicatedness
# otherwise.
sub is_complicated_8086_code($$$) {
  my($data, $fixupr, $symbolsr) = @_;
  my $size = length($data);
  # 1-byte relative jumps: [\x70-\x7F\xE3\xEB].
  # 2-byte relative jumps and calls: [\xE8\xE9]..
  my @splits;
  for my $fixup (@$fixupr) {
    my($endofs, $ofs, $ltypem, $symbol) = @$fixup;
    return "relative fixup with nonzero base" if $ltypem < 0 and substr($data, $ofs, 2) ne "\0\0";
    push @splits, $endofs if $ltypem < 0;
  }
  push @splits, map { $_->[0] } @$symbolsr;
  push @splits, $size;  # Sentinel.
  @splits = sort { $a <=> $b } @splits;
  my $si = 0;
  pos($data) = 0;
  my @relative_splits;
  my $result = "";
  while ($data =~ m@\G(
      [\x70-\x7F\xE3\xEB]([\x00-\xFF]) |  # 1-byte replative jumps ($2).
      [\xE8\xE9]([\x00-\xFF]{2}) |  # 2-byte replative jump/call ($3).
      ($STR_INST_80286_RE) |  # 80286 string instruction ($4).
      $INST_80286_RE)@gcxo) {
    my $endpos = pos($data);
    while ($endpos > $splits[$si]) {
      #print STDERR "warning: split instruction: $pos...$endpos [$si]=$splits[$si]\n" if $pos != $splits[$si];
      return "split instruction" if $endpos - length($1) != $splits[$si];
      ++$si;
    }
    if (defined($2) or defined($3)) {  # 1-byte relative jump.
      my $target;
      if (defined($2)) {
        $target = $endpos + unpack("c", $2);
      } else {
        $target = unpack("v", $3);
        $target = $endpos + $target - (($target & 0x8000) << 1);
      }
      if ($target != $endpos) {  # Shortcut, this would always succeed.
        return "relative jump/call target out of range" if $target < 0 or $target > $size;
        push @relative_splits, $target;
      }
    } elsif (defined($4)) {
      $result = 0;  # String instruction detected.
    }
  }
  return "unknown instruction" if pos($data) != $size;
  if (@relative_splits) {
    @splits = sort { $a <=> $b } @relative_splits;
    push @splits, $size;  # Sentinel.
    @relative_splits = ();  # Save memory.
    $si = 0; pos($data) = 0;
    while ($data =~ m@\G($INST_80286_RE)@gco) {
      my $endpos = pos($data);
      while ($endpos > $splits[$si]) {
        #print STDERR "warning: split target instruction: $pos...$endpos [$si]=$splits[$si]\n" if $pos != $splits[$si];
        return "split target instruction" if $endpos - length($1) != $splits[$si];
        ++$si;
      }
    }
    return "unknown instruction" if pos($data) != $size;  # Should happen above, not here.
  }
  $result
}

my @SEGMENT_ORDER = qw(_TEXT CONST CONST2 _DATA _BSS);  # Constant, OpenWatcom wcc.
my %ASM_DATA_OP = (1 => "db", 2 => "dw", 4 => "dd", 8 => "dq");  # Constant, nasm.

sub emit_nasm_segment($$$$$$) {
  my($segment_name, $exef, $size, $data, $symbolsr, $fixupr) = @_;
  print $exef "OBJ_SEGMENT_${segment_name}_start:\n";
  print $exef "OBJ_SEGMENT_${segment_name}_size equ $size\n";

  # Sort by ofs ascending.
  my @symbols = sort { $a->[0] <=> $b->[0] or $a->[1] cmp $b->[1] } @$symbolsr;
  my $fi = 0; my $si = 0; my $i = 0;  # $fixupr is already sorted.
  my $is_bss = $segment_name eq "_BSS";
  my $chunk_sub = $segment_name eq "_BSS" ? sub { my $size = $_[0] - $i; print $exef "resb $size\n"; $i = $_[0]; } : sub {
    my $j = $_[0];
    while ($fi < @$fixupr and $fixupr->[$fi][1] < $j) {  # Apply fixup.
      my($endofs, $ofs, $ltypem, $symbol) = @{$fixupr->[$fi++]};
      my $line = unpack("H*", substr($data, $i, $ofs - $i)); $line =~ s@(..)(?=.)@$1, 0x@sg; print $exef "db 0x$line\n";
      my $base = sprintf("0x%x", unpack("v", substr($data, $ofs, 2)));
      my $size = $endofs - $ofs;
      my $rel = $ltypem < 0 ? "-(\$+$size)" : "";
      print $exef "$ASM_DATA_OP{$size} $base+$symbol$rel\n";
      $i = $endofs;
    }
    my $line = unpack("H*", substr($data, $i, $j - $i)); $line =~ s@(..)(?=.)@$1, 0x@sg; print $exef "db 0x$line\n";
    $i = $j;
  };
  while ($si < @symbols) {
    my $j = $symbols[$si][0];
    if ($j > $size or $j < $i) {
      print $exef "$symbols[$si][1] equ $j+OBJ_SEGMENT_${segment_name}_start\n";
      ++$si; next
    }
    $chunk_sub->($j) if $j > $i;
    for (; $si < @symbols and $symbols[$si][0] == $j; ++$si) {
      print $exef "$symbols[$si][1]:\n";
    }
  }
  $chunk_sub->($size) if $size > $i;
}

sub link_executable($$@) {
  my $is_nasm = $_[0]; my $exefn = $_[1];  # Also uses: $CPUF and $EXT.
  local $0 = "dosmc-linker-$EXT" . ($is_nasm ? "-nasm" : "");
  my $NASMCPU = $CPUF eq "-0" ? "8086" : substr($CPUF, 1) . "86";
  splice @_, 0, 2;  # Remove the first 2 arguments, keep .obj files.
  die "$0: assert: single .obj file expected" if @_ != 1;
  my $objfn = $_[0];
  die "$0: fatal: unknown EXT: $EXT\n" if $EXT ne "exe" and $EXT ne "com";
  my $is_exe = $EXT eq "exe";  # Otherwise .com.
  my $exef;  # May be of .com, .exe or .nasm format.
  my $f;  # Of OMF .obj format, typically created by wcc or `nasm -f obj'.
  eval {
  die "$0: fatal: cannot open for writing: $exefn\n" if !open($exef, ">", $exefn);
  die "$0: fatal: cannot open obj file for reading: $objfn\n" if !open($f, "<", $objfn);
  # Based on: https://pierrelib.pagesperso-orange.fr/exec_formats/OMF_v1.1.pdf
  my @lnames = ("-LN0");
  my %segment_name_ok = map { $_ => 1 } @SEGMENT_ORDER;
  my %segment_sizes;
  my @segment_names = ("-SN");
  my %ledata = map { $_ => "" } @SEGMENT_ORDER;  # $segment_name => $ledata_str.
  my %symbol_ofs;   # $symbol => $ofs.
  my %segment_symbols = map { $_ => [] } @SEGMENT_ORDER;  # $segment_name => [[$ofs, $symbol], ...].
  my @extdef = ("-ED");
  my %fixupp = map { $_ => [] } @SEGMENT_ORDER;  # $segment_name => [[$endofs, $ofs, $ltypem, $symbol], ...].
  my $has_string_instructions = 0;
  my($last_segment_name, $last_ofs);
  my $obj_symbol_prefix = "O1\$";
  while (1) {
    my $data;
    die "$0: fatal: EOF in obj record header\n" if (read($f, $data, 3) or 0) != 3;
    my($type, $size) = unpack("Cv", $data);
    die "$0: fatal: empty obj record\n" if !$size;
    last if $type == 0x8a;  # MODEND.
    #printf STDERR "info: RECORD 0x%x %d\n", $type, $size;
    die "$0: fatal: EOF in obj record header\n" if (read($f, $data, $size) or 0) != $size;
    --$size; substr($data, -1) = "";  # Ignore checksum.
    if ($type == 0x96) {  # LNAMES.
      for (my $i = 0; $i < $size; ) {
        my $fsize = vec($data, $i++, 8);
        die "$0: fatal: EOF in LNAMES name\n" if $i + $fsize > $size;
        push(@lnames, $fsize == 0 ? "-LNEMPTY" : substr($data, $i, $fsize));
        $i += $fsize;
      }
    } elsif ($type == 0x98) {  # SEGDEF.
      die "$0: fatal: SEGDEF too short" if $size < 6;
      my $attr = vec($data, 0, 8);
      die "$0: fatal: unsupported alignment\n" if ($attr >> 5) == 0;
      my $is_big = ($attr >> 1) & 1;
      my($segment_size, $segment_name_idx) = unpack("vC", substr($data, 1, 3));
      die "$0: fatal: bad segment_name_idx\n" if $segment_name_idx >= @lnames;
      $segment_size = 0x10000 if $is_big;
      my $segment_name = $lnames[$segment_name_idx];
      die "$0: fatal: unsupported segment: $segment_name\n" if !$segment_name_ok{$segment_name};
      die "$0: fatal: duplicate segment: $segment_name\n" if exists($segment_sizes{$segment_name});
      $segment_sizes{$segment_name} = $segment_size;
      # Some segment indexes would become 2 bytes, we do not support that.
      die "$0: fatal: too many segments\n" if @segment_names >= 127;
      push @segment_names, $segment_name;
      #print STDERR "info: SEGDEF: $segment_name size=$segment_size\n";
    } elsif ($type == 0x99) {  # Long SEGDEF.
      die "$0: fatal: long SEGDEF not supported\n";
    } elsif ($type == 0xa0) {  # LEDATA.
      die "$0: fatal: LEDATA too short" if $size < 3;
      my($segment_idx, $ofs) = unpack("Cv", substr($data, 0, 3));
      die "$0: fatal: unknown segment: $segment_idx\n" if $segment_idx >= @segment_names;
      my $segment_name = $segment_names[$segment_idx];
      $size -= 3; substr($data, 0, 3) = "";
      #print STDERR "info: LEDATA: $segment_name ofs=$ofs size=$size\n";
      die "$0: fatal: gap in LEDATA for $segment_name\n" if length($ledata{$segment_name}) != $ofs;
      $ledata{$segment_name} .= $data;
      $last_segment_name = $segment_name;  $last_ofs = $ofs;  # For FIXUPP.
    } elsif ($type == 0xa1) {  # Long LEDATA.
      die "$0: fatal: long LEDATA not supported\n";
    } elsif ($type == 0x90 or $type == 0xb6) {  # PUBDEF or LPUBDEF(static).
      my $recname = $type == 0xb6 ? "LPUBDEF" : "PUBDEF";
      # $ as a prefix would make nasm to treat it as a symbol name, e.g. $ax
      # as ax. A $ in the middle of the symbol name ias also good to force
      # it to be a symbol in nasm.
      my $symbol_prefix = $type == 0xb6 ? $obj_symbol_prefix : "G\$";
      die "$0: fatal: $recname too short" if $size < 2;
      my $segment_idx = vec($data, 1, 8);
      die "$0: fatal: unknown segment: $segment_idx\n" if $segment_idx >= @segment_names;
      my $segment_name = $segment_names[$segment_idx];
      for (my $i = 2; $i < $size; $i += 3) {
        my $fsize = vec($data, $i++, 8);
        die "$0: fatal: EOF in $recname entry\n" if $i + $fsize + 3 > $size;
        my $symbol = $symbol_prefix . substr($data, $i, $fsize);
        $i += $fsize;
        my($ofs, $type) = unpack("vC", substr($data, $i, 3));
        #print STDERR "info: $recname $segment_name $symbol $ofs $type\n";
        # Also because we do not support parsing 2-byte type index.
        die "$0: fatal: bad symbol type: symbol=$symbol type=$type\n" if $type != 0;
        die "$0: fatal: duplicate symbol: $symbol\n" if exists($symbol_ofs{$symbol});
        $symbol_ofs{$symbol} = $ofs;
        push @{$segment_symbols{$segment_name}}, [$ofs, $symbol];
      }
    } elsif ($type == 0x91) {  # Long PUBDEF.
      die "$0: fatal: long PUBDEF not supported\n";
    } elsif ($type == 0xb7) {  # Long LPUBDEF.
      die "$0: fatal: long LPUBDEF not supported\n";
    } elsif ($type == 0x8c or $type == 0xb4) {  # EXTDEF or LEXTDEF(static).
      my $recname = $type == 0xb4 ? "LEXTDEF" : "EXTDEF";
      # $ is for nasm to treat it as a symbol name, e.g. $ax as ax.
      my $symbol_prefix = $type == 0xb4 ? $obj_symbol_prefix : "G\$";
      for (my $i = 0; $i < $size; ) {
        my $fsize = vec($data, $i++, 8);
        die "$0: fatal: EOF in $recname entry\n" if $i + $fsize + 1 > $size;
        # $ is for nasm to take the symbol as an identifier.
        my $symbol = $symbol_prefix . substr($data, $i, $fsize);
        $i += $fsize;
        my $type = unpack("C", substr($data, $i++, 1));
        # Also because we do not support parsing 2-byte type index.
        die "$0: fatal: unsupported $recname type: symbol=$symbol type=$type\n" if $type != 0;
        #print STDERR "info: $recname $symbol $type\n";
        push @extdef, $symbol;
      }
    } elsif ($type == 0xb5) {  # Long LEXTDEF.
      die "$0: fatal: long LEXTDEF not supported\n";
    } elsif ($type == 0x9c) {  # FIXUPP.
      die "$0: fatal: FIXUPP must follow LEDATA\n" if !defined($last_ofs);
      die "$0: fatal: FIXUPP not allowed in _BSS" if $last_segment_name eq "_BSS";
      for (my $i = 0; $i < $size; ) {
        die "$0: fatal: EOF in FIXUP header\n" if $i + 3 > $size;
        my ($a, $ofs, $fd) = unpack("CCC", substr($data, $i, 3));
        #print STDERR "info: FIXUPP bytes " . unpack("H*", substr($data, $i, 3)) . "\n";
        #printf STDERR "info: FIXUPP a=0x%x dro=0x%x fd=0x%x\n", $a, $ofs, $fd;
        $i += 3;
        die "$0: fatal: THREAD subrecord not supported\n" if !($a & 0x80);
        die "$0: fatal: frame thread not supported\n" if $fd & 0x80;
        die "$0: fatal: target thread not supported\n" if $fd & 8;
        my $is_self = ~($a >> 6) & 1;
        my $ltype = ($a >> 2) & 15;
        my $lsize = $ltype == 1 ? 2 : undef;
        die "$0: fatal: unsupported FIXUPP location type: $ltype\n" if !defined($lsize);
        my $ltypem = $is_self ? -$ltype : $ltype;
        $ofs = $last_ofs + ($ofs | ($a & 3) << 8);
        my $endofs = $ofs + $lsize;
        die "$0: fatal: FIXUPP data record offset too large\n" if
            $endofs > length($ledata{$last_segment_name});
        my $frame = ($fd >> 4) & 7;
        my $target = $fd & 7;
        my $fixuppr = $fixupp{$last_segment_name};
        die "$0: fatal: FIXUPP must not overlap\n" if @$fixuppr and $fixuppr->[-1][0] > $ofs;
        my $symbol;
        if ($frame == 5 and $target == 6) {
          die "$0: fatal: EOF in FIXUPP target\n" if $i >= $size;
          my $extdef_idx = vec($data, $i++, 8);
          if ($extdef_idx >= 0x80) {
            die "$0: fatal: EOF in FIXUPP target 2-byte extdef_idx\n" if $i >= $size;
            $extdef_idx = ($extdef_idx - 0x80) << 8 | vec($data, $i++, 8);
          }
          die "$0: fatal: FIXUPP EXTDEF index is 0\n" if $extdef_idx == 0;
          die "$0: fatal: unknown FIXUPP EXTDEF index: $extdef_idx\n" if $extdef_idx >= @extdef;
          $symbol = $extdef[$extdef_idx];
          #print STDERR "info: FIXUPP 16-bit $is_self \@$ofs EXTDEF $symbol\n";
        } elsif ($frame == 1 and $target == 4) {
          # We usually get it for string literals in CONST.
          die "$0: fatal: EOF in FIXUPP target\n" if $i + 2 > $size;
          my $segment_idx = vec($data, $i + 1, 8);
          $i += 2;
          die "$0: fatal: unknown segment: $segment_idx\n" if $segment_idx >= @segment_names;
          my $segment_name = $segment_names[$segment_idx];
          #print STDERR "info: FIXUPP 16-bit $is_self \@$ofs SEGMENT $segment_name\n";
          $symbol = "OBJ_SEGMENT_${segment_name}_start";
        } else {
          die "$0: fatal: unsupported FIXUPP: frame=$frame target=$target\n";
        }
        push @$fixuppr, [$endofs, $ofs, $ltypem, $symbol];
      }
    } elsif ($type == 0x9d) {  # Long FIXUPP.
      die "$0: fatal: long FIXUPP not supported\n";
    } elsif ($type == 0x80) {  # THEADR.
    } elsif ($type == 0x88) {  # COMENT.
    } elsif ($type == 0x9a) {  # GRPDEF.
    } else {
      # We do not need to support common symbols, wcc never generates them.
      die sprintf("%s: fatal: unsupported obj record type: type=0x%x size=%d\n", $0, $type, $size);
    }
    $last_segment_name = $last_ofs = undef if $type != 0xa0 and $type != 0xa1 and $type != 0x9c;
  }
  # This should be done for each input .obj files.
  my $code_type = is_complicated_8086_code($ledata{_TEXT}, $fixupp{_TEXT}, $segment_symbols{_TEXT});
  if ($code_type) {  # Complicated.
    $has_string_instructions = 1 if $ledata{_TEXT} =~ m@$STR_INST_80286_RE@o;  # Conservative.
  } else {
    $has_string_instructions = 1 if length($code_type);
  }

  for my $segment_name (@SEGMENT_ORDER) {
    # Typically $segment_sizes{_BSS} is missing, put it back.
    $segment_sizes{$segment_name} = 0 if !exists($segment_sizes{$segment_name});
    my $size = $segment_name eq "_BSS" ? 0 : $segment_sizes{$segment_name};
    die "$0: assert: segment size mismatch for $segment_name\n" if
        length($ledata{$segment_name}) != $size;
  }

  my %undefined_symbols = map { $_ => 1 } @extdef;
  delete $undefined_symbols{$extdef[0]};
  for my $symbol (keys %symbol_ofs) {
    delete $undefined_symbols{$symbol};
  }
  # Helpfully added by wcc if there is main(...) with nonzero arguments.
  my $do_use_argc = exists($undefined_symbols{"G\$__argc"});
  delete $undefined_symbols{"G\$__argc"};
  delete $undefined_symbols{"G\$_cstart_"};
  die "$0: fatal: missing symbol: G\$_small_code_\n" if !exists($undefined_symbols{"G\$_small_code_"});
  delete $undefined_symbols{"G\$_small_code_"};
  my @undefined_symbols = sort keys %undefined_symbols;
  die "$0: fatal: undefined symbols: @undefined_symbols\n" if @undefined_symbols;

  my $entry_count = (defined($symbol_ofs{"G\$main_"}) + defined($symbol_ofs{"G\$_start_"}));
  die "$0: fatal: too many entry points (main functions)\n" if $entry_count > 1;
  die "$0: fatal: missing entry point (main function)\n" if $entry_count == 0;

  my $exit_code = get_8086_exit_code(\%ledata, \%symbol_ofs);
  if (defined($exit_code)) {  # Shortcut if the program immediately exits.
    for my $segment_name (@SEGMENT_ORDER) {
      $ledata{$segment_name} = ""; $segment_sizes{$segment_name} = 0; $fixupp{$segment_name} = []; $segment_symbols{$segment_name} = [];
    }
    delete $symbol_ofs{"G\$main_"};
    $symbol_ofs{"G\$_start_"} = 0;
    push @{$segment_symbols{_TEXT}}, [0, "_start_"];
    if ($is_exe or $exit_code) {
      $ledata{_TEXT} = pack("aCa3", "\xB8", $exit_code, "\x4C\xCD\x21");  # mov ax, 0x4c??;; int 0x21
    } else {
      $ledata{_TEXT} = "\xC3";  # ret
    }
    $segment_sizes{_TEXT} = length($ledata{_TEXT});
  }

  my $does_entry_point_return = !defined($exit_code);  # TODO(pts): Smarter detection.
  my $is_data_used = !defined($exit_code);
  my $need_clear_ax = (defined($symbol_ofs{"G\$main_"}) and $do_use_argc);
  my $do_clear_bss = $segment_sizes{_BSS} + ($need_clear_ax << 1) > 14;  # 14 == length($clear_bss_full).
  # _DATA comes before _BSS in @SEGMENT_ORDER, move all (\0) bytes from _BSS to _DATA.
  if (!$do_clear_bss) { $ledata{_DATA} .= "\0" x $segment_sizes{_BSS}; $segment_sizes{_DATA} += $segment_sizes{_BSS}; $segment_sizes{_BSS} = 0; }
  my $need_clear_df = ($do_clear_bss or $has_string_instructions);
  for my $segment_name (@SEGMENT_ORDER) {
    die "$0: assert: segment size mismatch for $segment_name\n" if
        length($ledata{$segment_name}) != ($segment_name eq "_BSS" ? 0 : $segment_sizes{$segment_name});
  }

  if ($is_nasm) {  # emit_nasm.
    my($fullprog_code, $fullprog_data, $fullprog_bss, $fullprog_end);
    # No need to disambiguate NASM symbols like code_end, because
    # wcc adds _ prefix or suffix to all symbols (including static ones).
    if ($is_exe) {
# Based on https://github.com/pts/pts-nasm-fullprog/blob/master/fullprog_dosexe.inc.nasm
$fullprog_code = q(
section .text align=1 vstart=-0x10
; DOS .exe header, similar to: https://stackoverflow.com/q/14246493/97248
exe_header:
db 0x4d, 0x5a  ; MZ Signature.
dw ((code_end-exe_header)+(data_end-data_start))&511  ; Image size low 9 bits.
dw ((code_end-exe_header)+(data_end-data_start)+511)>>9  ; Image size high bits, including header and relocations (none here), excluding .bss, rounded up.
dw 0  ; Relocation count.
dw 1  ; Paragraph (16 byte) count of header. Points to code_startseg.
dw (bss_end-bss_start+15-(-((data_end-data_start)+(code_end-code_startseg))&15))>>4  ; Paragraph count of minimum required memory.
dw 0xffff  ; Paragraph count of maximum required memory.
dw (code_end-code_startseg)>>4  ; Stack segment (ss) base, will be same as ds. Low 4 bits are in vstart= of .data.
code_startseg:
dw (bss_end-bss_start)+(data_end-data_start) ; Stack pointer (sp).
dw 0  ; No file checksum.
dw code_start-code_startseg  ; Instruction pointer (ip): 8.
dw 0  ; Code segment (cs) base.
; We reuse the final 4 bytes of the .exe header (dw relocation_table_ofs,
; overlay_number) for code.
code_start:
);
$fullprog_data = q(
code_end:
; Fails with `error: TIMES value -... is negative` if code is too large (>~64 KiB).
times -((code_end-code_startseg)>>16) db 0
section .data align=1 vstart=((code_end-code_startseg)&15)
data_start:
);
$fullprog_bss = q(
data_end:
section .bss align=1  ; vstart=0
bss_start:
);
$fullprog_end = q(
auto_stack:  ; Autodetect stack size to fill data segment to 65535 bytes.
resb ((auto_stack-bss_start)+(data_end-data_start))&1  ; Word-align stack, for speed.
auto_stack_aligned:
%define stack_size (65534-((auto_stack_aligned-bss_start)+(data_end-data_start)))
times (stack_size-10)>>256 resb 0  ; Assert that stack size is at least 10.
stack: resb stack_size
bss_end:
; Fails with `error: TIMES value -... is negative` if data is too large (>~64 KiB).
times -(((bss_end-bss_start)+(data_end-data_start))>>16) db 0
);
    } else {  # .com
# Based on https://github.com/pts/pts-nasm-fullprog/blob/master/fullprog_dosexe.inc.nasm
$fullprog_code = q(
section .text align=1 vstart=0x100  ; org 0x100
code_start:
);
$fullprog_data = q(
code_end:
; Fails with `error: TIMES value -... is negative` if code is too large (>~64 KiB).
times -((code_end-code_start+0x100)>>16) db 0
section .data align=1 vstart=0x100+(code_end-code_start)  ; vfollows=.text is off by 2 bytes.
data_start:
);
$fullprog_bss = q(
data_end:
section .bss align=1  ; vstart=0
bss_start:
);
$fullprog_end = q(
auto_stack:  ; Autodetect stack size to fill main segment to almost 65535 bytes.
%define stack_size (65535-3-((auto_stack-bss_start)+(data_end-data_start)+(code_end-code_start+0x100)))
times (stack_size-10)>>256 resb 0  ; Assert that stack size is at least 10.
; This is fake, end of stack depends on DOS, typically sp==0xfffe or sp==0xfffc.
stack: resb stack_size
bss_end:
call__fullprog_end:  ; Make fullprog_code without fullprog_end fail.
; Fails with `error: TIMES value -... is negative` if data is too large (>~64 KiB).
; +3 because some DOS systems set sp to 0xfffc instead of 0xffff
; (http://www.fysnet.net/yourhelp.htm).
times -(((bss_end-bss_start)+(data_end-data_start)+(code_end-code_start+0x100)+3)>>16) db 0
);
    }
    print $exef qq(bits 16\ncpu $NASMCPU\n);
    print $exef qq($fullprog_code\n);
    print $exef qq(db 0x16  ; push ss\ndb 0x1f  ; pop ds\n) if $is_exe and $is_data_used;
    print $exef qq(cld\n) if $need_clear_df;
    if ($do_clear_bss) {
      print $exef qq(push es\npush ds\npop es\nmov di, bss_start\nmov cx, (stack-bss_start+1)>>1\nxor ax, ax\nrep stosw\npop es\n);  # clear_bss.
    } elsif ($need_clear_ax) {
      print $exef qq(db 0x31, 0xC0  ; xor ax, ax\n  ; argc=0);
    }
    if (defined($symbol_ofs{"G\$_start_"})) {  # TODO(pts): Keep these consistent with emit_executable.
      if ($is_exe and $does_entry_point_return) {
        print $exef qq(db 0xE8\ndw 0x0000+G\$_start_-\(\$+2\)  ; call G\$_start_\n);
        print $exef qq(db 0xB8, 0, 0x4C, 0xCD, 0x21  ; mov ax, 0x4c00;; int 0x21  ; EXIT with code 0.\n);
      } elsif ($symbol_ofs{"G\$_start_"} == 0) {  # Code starts with _start.
      } else {
        print $exef qq(db 0xE9\ndw 0x0000+G\#_start_-\(\$+2\)  ; jmp strict word G\$_start_\n);
      }
    } elsif (defined($symbol_ofs{"G\$main_"}) and $do_use_argc) {
      # OpenWatcom wcc does not support non-constant initializers, so we can call
      # main now.
      print $exef qq(xor dx, dx\ncall G\$main_\nmov ah, 0x4c  ; dx: argv=NULL; EXIT, exit code in al\nint 0x21\n);
    } elsif (defined($symbol_ofs{"G\$main_"})) {
      print $exef qq(call G\$main_\nmov ah, 0x4c  ; EXIT, exit code in al\nint 0x21\n);
    }
    for my $segment_name (@SEGMENT_ORDER) {
      print $exef qq($fullprog_data\n) if $segment_name eq "CONST";  # Double-quoted string literals.
      print $exef qq($fullprog_bss\n) if $segment_name eq "_BSS";
      emit_nasm_segment($segment_name, $exef, $segment_sizes{$segment_name}, $ledata{$segment_name}, $segment_symbols{$segment_name}, $fixupp{$segment_name});
    }
    print $exef qq($fullprog_end\n);
  } else {  # emit_executable.
    my $init_regs = "";
    $init_regs .= "\x16\x1F" if $is_exe and $is_data_used;  # push ss; pop ds
    $init_regs .= "\xFC" if $need_clear_df;  # String instructions (e.g. movsb, stosw) need df=0 (cld).
    # push ds;; pop es;; mov di, bss_start;; mov cx, (stack-bss_start+1)>>1;; xor ax, ax;; rep stosw;; pop es
    my $clear_bss = $do_clear_bss ? pack("a4va1va5", "\x06\x1E\x07\xBF", 0, "\xB9", ($segment_sizes{_BSS} + 1) >> 1, "\x31\xC0\xF3\xAB\x07") :  # Affected by fixups below.
        $need_clear_ax ? "\x31\xC0" : "";  # xor ax, ax  ; argc=0.
    # $call_main is affected by fixups below.
    my($call_main, $call_main_symbol, $call_main_ofs);
    if (defined($symbol_ofs{"G\$_start_"})) {
      if ($is_exe and $does_entry_point_return) {
        # call _start_;; mov ax, 0x4c00;; int 0x21  ; EXIT with code 0.
        $call_main = pack("ava5", "\xE8", 0, "\xB8\x00\x4C\xCD\x21");
        $call_main_symbol = "G\$_start_"; $call_main_ofs = length($call_main) - 7;
      } elsif ($symbol_ofs{"G\$_start_"} == 0) {  # Code starts with _start.
        $call_main = ""; $call_main_symbol = $call_main_ofs = undef;
      } else {
        # !! TODO(pts): Instead of the jmp, move the code of $clear_bss and $call_main just above _start.
        $call_main = pack("a1v", "\xE9", 0);  # jmp strict word _start_
        $call_main_symbol = "G\$_start_"; $call_main_ofs = length($call_main) - 2;
      }
    } elsif (defined($symbol_ofs{"G\$main_"}) and $do_use_argc) {
      # OpenWatcom wcc does not support non-constant initializers, so we can call
      # main now.
      # xor dx, dx;; call G$main_;; mov ah, 0x4c;; int 0x21  ; dx: argv=NULL; EXIT, exit code in al
      $call_main = pack("a3va4", "\x31\xD2\xE8", 0, "\xB4\x4C\xCD\x21");
      $call_main_symbol = "G\$main_"; $call_main_ofs = length($call_main) - 6;
    } elsif (defined($symbol_ofs{"G\$main_"})) {
      # call main_;; mov ah, 0x4c;; int 0x21  ; EXIT, exit code in al
      $call_main = pack("a1va4", "\xE8", 0, "\xB4\x4C\xCD\x21");
      $call_main_symbol = "G\$main_"; $call_main_ofs = length($call_main) - 6;
    }
    my $vofs = ($is_exe ? 8 : 0x100) + length($init_regs) + length($clear_bss);
    my %segment_vofs;
    $segment_vofs{call_main} = $vofs; $vofs += length($call_main);  # For the relocation below.
    $segment_vofs{_TEXT} = $vofs; $vofs += length($ledata{_TEXT});
    my $after_text_vofs = $vofs;
    $vofs &= 15 if $is_exe;
    my $dgroup_vofs = $segment_vofs{CONST} = $vofs; $vofs += length($ledata{CONST});
    $segment_vofs{CONST2} = $vofs; $vofs += length($ledata{CONST2});
    $segment_vofs{_DATA} = $vofs; $vofs += length($ledata{_DATA});
    $segment_vofs{_BSS} = $vofs; $vofs += $segment_sizes{_BSS};
    my %symbol_vofs;  # $symbol => $vofs + $obj_ofs.
    for my $segment_name (keys %segment_symbols) {
      my $this_segment_vofs = $segment_vofs{$segment_name};
      $symbol_vofs{"OBJ_SEGMENT_${segment_name}_start"} = $this_segment_vofs;
      for my $pair (@{$segment_symbols{$segment_name}}) {
        my($ofs, $symbol) = @$pair;
        $symbol_vofs{$symbol} = $this_segment_vofs + $ofs;
      }
    }
    my $data_size = $segment_sizes{CONST} + $segment_sizes{CONST2} + $segment_sizes{_DATA};
    die "$0: fatal: data too large\n" if $data_size + $segment_sizes{_BSS} > 65535;  # !! Allow 65536, also in nasm.
    die "$0: fatal: code too large\n" if $after_text_vofs > 65535;  # !! Allow 65536, also in nasm.
    die "$0: fatal: code+data too large for .com\n" if !$is_exe and $vofs > 65535;
    my $stack_align_size = ($data_size + $segment_sizes{_BSS}) & 1;
    my $stack_size = 65535 - (($data_size + $segment_sizes{_BSS} + ($is_exe ? 0 : 2 + $after_text_vofs) + 1) | 1);
    die "$0: fatal: stack too small (code and data too large)\n" if $stack_size < 10;
    die "$0: assert: bad stack size\n"  if $is_exe and $data_size + $segment_sizes{_BSS} + $stack_align_size + $stack_size != 65534;
    if ($is_exe) {
      my $image_size = 24 + length($init_regs) + length($clear_bss) + length($call_main) + $segment_sizes{_TEXT} + $data_size;
      my $exe_header = pack("a2v11", "MZ", $image_size & 511, ($image_size + 511) >> 9, 0, 1,
          ($segment_sizes{_BSS} + $stack_align_size + $stack_size + 15-(-($data_size + $after_text_vofs) & 15)) >> 4,
          0xffff, $after_text_vofs >> 4, $data_size + $segment_sizes{_BSS} + $stack_align_size + $stack_size, 0, 8, 0);
      print $exef $exe_header;
    }
    substr($clear_bss, 4, 2) = pack("v", $segment_vofs{_BSS}) if length($clear_bss) >= 6;
    substr($call_main, $call_main_ofs, 2) = pack("v", $symbol_vofs{$call_main_symbol} - ($call_main_ofs + 2 + $segment_vofs{call_main})) if
        defined($call_main_ofs);
    # Tiny version of
    # https://github.com/open-watcom/open-watcom-v2/blob/master/bld/clib/startup/a/cstrt086.asm
    print $exef $init_regs, $clear_bss, $call_main;
    for my $segment_name (@SEGMENT_ORDER) {
      my $data = $ledata{$segment_name};
      my $this_segment_vofs = $segment_vofs{$segment_name};
      for my $fixup (@{$fixupp{$segment_name}}) {  # Apply fixups.
        my($endofs, $ofs, $ltypem, $symbol) = @$fixup;
        die "$0: assert: bad endofs in fixup\n" if $endofs > length($data);
        die "$0: assert: unknown symbol in fixup: $symbol\n" if !defined($symbol_vofs{$symbol});
        my $svofs = $symbol_vofs{$symbol} + unpack("v", substr($data, $ofs, 2));
        #printf STDERR "info: fixup \@0x%04x base=0x%04x symbol=%s add=0x%04x is_rel=%d\n", $ofs, unpack("v", substr($data, $ofs, 2)), $symbol, $symbol_vofs{$symbol}, ($ltypem < 0 or 0);
        $svofs -= $endofs + $this_segment_vofs if $ltypem < 0;
        substr($data, $ofs, 2) = pack("v", $svofs);
      }
      print $exef $data;
    }
  }
  };  # End of eval block.
  close($f) if $f;
  close($exef) if $exef;
  if ($@) { print STDERR $@; exit(4 + $is_nasm); }
}

# --- End of linker, main code continues.

my $objfn = "$SRCBASE.tmp.obj";
if ($PL eq "-ce" or $PL eq "-cn") {
  my $is_nasm = $PL eq "-cn" ? 1 : 0;
  my $exefn = $is_nasm ? "$SRCBASE.tmp.nasm" : $EXEOUT;
  print_command("//link", $EXT, $CPUF, $is_nasm,  $exefn, $objfn) if !length($Q);
  link_executable($is_nasm,  $exefn, $objfn);
  # .nasm output ($EXEFN) cannot be used to produce an .obj file again (i.e. nasm -f obj).
  # TODO(pts): Add support for this, preferably autodetection.
  if ($is_nasm and run_command("nasm", "-f", "bin", "-o", $EXEOUT, $exefn)) {
    print STDERR "$0: fatal: nasm failed\n"; exit(6);
  }
} elsif ($PL eq "-cw") {
  # Output of wdis ($EXEOUT) can be fed to wasm again to produce an .obj file.
  if (run_command("wdis", "-a", "-fi", "-i=\@", $objfn, " > $EXEOUT")) {
    print STDERR "$0: fatal: wdis failed\n"; exit(7);
  }
}

print ": $0 OK.\n" if !length($Q);
