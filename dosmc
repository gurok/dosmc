#! /bin/sh --
# by pts@fazekas.hu at Thu Jun 25 00:59:56 CEST 2020
#
# TODOs:
#
# !! Change _main0 to void _start(void);
# !! Optimize away call in entry point of main and _start.
# !! Optimize away extra exit after _start.
# !! Optimize away `pop ...' registers at end of _start.
# !! Optimize `mov al, ...; mov ah, ...' at end of main and _start.
# !! Change .bss do .data (\0) for short .bss.
# !! Omit the zero-initialize if .bss is empty or it contains argv only.
# !! Add option for word alignment of data segments, for speed.
# !! TODO(pts): Add automatic argv splitting for main unless -D_NOARG_MAIN.
#
# !! Allow .obj files from NASM, give source example for section.
# !! Allow .nasm source files, give source example for section.
# !! Allow .obj files from A86, give source example for section.
# !! Allow .obj files from WASM, give source example for section.
# !! Make simple_nasm_exe.nasm work (ds, ss, sp setup is unnecessary, remove that).

unset MYDIR BTARG ARG EXT LASTARG SRC SRCBASE EXEOUT Q PL PLL NFARGC NASMCPU CPUF

MYDIR="${0%/*}"

EXT=exe; Q=-q; CPUF=-0; PL=-ce
# Specify these interesting wcc or wcl flags near the beginning.
while test $# != 0; do
  case "$1" in
   -pl | -zs | -c | -ce | -cn) PL="$1" ;;  # Do preprocessor, syntax check, compile only, emit exec without nasm (nonstandard), emit exec with nasm (nonstandard).
   -q) Q=-q ;;  # Quiet. Default.
   -nq) Q= ;;
   -bt=dos | -bt=exe) EXT=exe  ;; # Default.
   -bt=com) EXT=com ;;
   -fo=*) EXEOUT="${1#*=}" ;;
   -ms) ;;
   -m*) echo "$0: fatal: only -ms (small memory model) supported: $1" >&2; exit 1 ;;
   -[0-6]) CPUF="$1" ;;
   -bt*) echo "$0: fatal: unsupported target: $1" >&2; exit 1 ;;
   -b* | -zW* | -zw*) echo "$0: fatal: unsupported Windows target: $1" >&2; exit 1 ;;
   -ecw) ;;  # We support only the Watcom default calling convention (and name mangling).
   -ec*) echo "$0: fatal: unsupported default calling convention: $1" >&2; exit 1 ;;
   *) break ;;  # All other flags will be passed to wcc verbatim.
  esac
  shift
done
for ARG in "$@"; do
  case "$ARG" in
   -*) ;;
   *) NFARGC="$NFARGC." ; LASTARG="$ARG" ;;
  esac
done

if test $# = 0 || test "$1" = "-?" || test "$1" = -h || test "$1" = --help; then
  test $# = 0 && exec >&2
  echo "dosmc: C compiler driver to produce tiny DOS .exe and .com executables"
  echo "This is free software, GNU GPL >=2.0. There is NO WARRANTY. Use at your risk."
  echo "Usage: $0 [<dosmc-flag> ...] [<wcc-flag> ...] <prog.c>"
  echo "To compile DOS .exe, specify no flag. To compile DOS .com, specify -bt=com"
  echo "See details on https://github.com/pts/dosmc"
  test $# = 0 && exit 1
  exit
fi
if test -z "$NFARGC"; then
  echo "$0: fatal: missing .c source file argument" >&2
  exit 1
fi
if test "$NFARGC" != .; then
  echo "$0: fatal: moultiple .c source file arguments" >&2
  exit 1
fi
if test "${LASTARG%.c}" = "$LASTARG"; then
  echo "$0: fatal: source file must be .c: $LASTARG" >&2
  exit 1
fi

if ! test -x "$MYDIR/ow2bin/wcc"; then
  echo "$0: fatal: missing executable $MYDIR/ow2bin/wcc; run $MYDIR/download_openwatcom.sh first" >&2
  exit 1
fi
unset WATCOM INCLUDE
SRC="$LASTARG"; SRCBASE="${SRC%.*}"
if ! test -f "$SRC"; then
  echo "$0: fatal: source file missing: $SRC" >&2
fi
if test "$PL" != -cn && test "$PL" != -ce; then
  if test "$PL" = -c; then
    test "$EXEOUT" || EXEOUT="$SRCBASE.obj"
  else
    PLL="$PL"
  fi
  test "$EXEOUT" && set -- -fo="$EXEOUT" "$@"
else
  test "$EXEOUT" || EXEOUT="$SRCBASE.$EXT"
  set -- -fo="$SRCBASE.tmp.obj" "$@"
fi
set -- -D__DOSMC__ "$@"
test "$EXT" = com && set -- -D__DOSMC_COM__ "$@"
NASMCPU=8086
test "$CPUF" = -0 || NASMCPU="${CPUF#-}86"

LINKER_CODE='
  BEGIN { $^W = 1 }
  use integer;
  use strict;

  die "$0: fatal: missing args\n" if @ARGV != 3;
  my($EXT, $NASMCPU, $is_nasm) = @ARGV;
  die "$0: fatal: unknown EXT: $EXT\n" if $EXT ne "exe" and $EXT ne "com";

  # Based on: https://pierrelib.pagesperso-orange.fr/exec_formats/OMF_v1.1.pdf
  my $f = \*STDIN;
  my @lnames = ("-LN0");
  my @SEGMENT_ORDER = qw(_TEXT CONST CONST2 _DATA _BSS);  # Constant, OpenWatcom.
  my %ASM_DATA_OP = (1 => "db", 2 => "dw", 4 => "dd", 8 => "dq");
  my %segment_name_ok = map { $_ => 1 } @SEGMENT_ORDER;
  my %segment_sizes;
  my @segment_names = ("-SN");
  my %ledata = map { $_ => "" } @SEGMENT_ORDER;  # $segment_name => $ledata_str.
  my %symbol_ofs;   # $symbol => $ofs.
  my %segment_symbols = map { $_ => [] } @SEGMENT_ORDER;  # $segment_name => [[$ofs, $symbol], ...].
  my @extdef = ("-ED");
  my %fixupp = map { $_ => [] } @SEGMENT_ORDER;  # $segment_name => [[$endofs, $ltypem, $label], ...].
  my($last_segment_name, $last_ofs);
  while (1) {
    my $data;
    die "$0: fatal: EOF in obj record header\n" if (read($f, $data, 3) or 0) != 3;
    my($type, $size) = unpack("Cv", $data);
    die "$0: fatal: empty obj record\n" if !$size;
    last if $type == 0x8a;  # MODEND.
    #printf STDERR "info: RECORD 0x%x %d\n", $type, $size;
    die "$0: fatal: EOF in obj record header\n" if (read($f, $data, $size) or 0) != $size;
    --$size; substr($data, -1) = "";  # Ignore checksum.
    if ($type == 0x96) {  # LNAMES.
      for (my $i = 0; $i < $size; ) {
        my $fsize = vec($data, $i++, 8);
        die "$0: fatal: EOF in LNAMES name\n" if $i + $fsize > $size;
        push(@lnames, $fsize == 0 ? "-LNEMPTY" : substr($data, $i, $fsize));
        $i += $fsize;
      }
    } elsif ($type == 0x98) {  # SEGDEF.
      die "$0: fatal: SEGDEF too short" if $size < 6;
      my $attr = vec($data, 0, 8);
      die "$0: fatal: unsupported alignment\n" if ($attr >> 5) == 0;
      my $is_big = ($attr >> 1) & 1;
      my($segment_size, $segment_name_idx) = unpack("vC", substr($data, 1, 3));
      die "$0: fatal: bad segment_name_idx\n" if $segment_name_idx >= @lnames;
      $segment_size = 0x10000 if $is_big;
      my $segment_name = $lnames[$segment_name_idx];
      die "$0: fatal: unsupported segment: $segment_name\n" if !$segment_name_ok{$segment_name};
      die "$0: fatal: duplicate segment: $segment_name\n" if exists($segment_sizes{$segment_name});
      $segment_sizes{$segment_name} = $segment_size;
      # Some segment indexes would become 2 bytes, we do not support that.
      die "$0: fatal: too many segments\n" if @segment_names >= 127;
      push @segment_names, $segment_name;
      #print STDERR "info: SEGDEF: $segment_name size=$segment_size\n";
    } elsif ($type == 0x99) {  # Long SEGDEF.
      die "$0: fatal: long SEGDEF not supported\n";
    } elsif ($type == 0xa0) {  # LEDATA.
      die "$0: fatal: LEDATA too short" if $size < 3;
      my($segment_idx, $ofs) = unpack("Cv", substr($data, 0, 3));
      die "$0: fatal: unknown segment: $segment_idx\n" if $segment_idx >= @segment_names;
      my $segment_name = $segment_names[$segment_idx];
      $size -= 3; substr($data, 0, 3) = "";
      #print STDERR "info: LEDATA: $segment_name ofs=$ofs size=$size\n";
      die "$0: fatal: gap in LEDATA for $segment_name\n" if length($ledata{$segment_name}) != $ofs;
      $ledata{$segment_name} .= $data;
      $last_segment_name = $segment_name;  $last_ofs = $ofs;  # For FIXUPP.
    } elsif ($type == 0xa1) {  # Long LEDATA.
      die "$0: fatal: long LEDATA not supported\n";
    } elsif ($type == 0x90 or $type == 0xb6) {  # PUBDEF or LPUBDEF(static).
      die "$0: fatal: PUBDEF too short" if $size < 2;
      my $segment_idx = vec($data, 1, 8);
      die "$0: fatal: unknown segment: $segment_idx\n" if $segment_idx >= @segment_names;
      my $segment_name = $segment_names[$segment_idx];
      for (my $i = 2; $i < $size; $i += 3) {
        my $fsize = vec($data, $i++, 8);
        die "$0: fatal: EOF in PUBDEF entry\n" if $i + $fsize + 3 > $size;
        my $symbol = substr($data, $i, $fsize);
        $i += $fsize;
        my($ofs, $type) = unpack("vC", substr($data, $i, 3));
        #print STDERR "info: PUBDEF $segment_name $symbol $ofs $type\n";
        # Also because we do not support parsing 2-byte type index.
        die "$0: fatal: bad symbol type: symbol=$symbol type=$type\n" if $type != 0;
        die "$0: fatal: duplicate symbol: $symbol\n" if exists($symbol_ofs{$symbol});
        $symbol_ofs{$symbol} = $ofs;
        push @{$segment_symbols{$segment_name}}, [$ofs, $symbol];
      }
    } elsif ($type == 0x91) {  # Long PUBDEF.
      die "$0: fatal: long PUBDEF not supported\n";
    } elsif ($type == 0xb7) {  # Long LPUBDEF.
      die "$0: fatal: long LPUBDEF not supported\n";
    } elsif ($type == 0x8c or $type == 0xb4) {  # EXTDEF or LEXTDEF(static).
      for (my $i = 0; $i < $size; ) {
        my $fsize = vec($data, $i++, 8);
        die "$0: fatal: EOF in EXTDEF entry\n" if $i + $fsize + 1 > $size;
        my $symbol = substr($data, $i, $fsize);
        $i += $fsize;
        my $type = unpack("C", substr($data, $i++, 1));
        # Also because we do not support parsing 2-byte type index.
        die "$0: fatal: unsupported EXTDEF type: symbol=$symbol type=$type\n" if $type != 0;
        #print STDERR "info: EXTDEF $symbol $type\n";
        push @extdef, $symbol;
      }
    } elsif ($type == 0xb5) {  # Long LEXTDEF.
      die "$0: fatal: long LEXTDEF not supported\n";
    } elsif ($type == 0x9c) {  # FIXUPP.
      die "$0: fatal: FIXUPP must follow LEDATA\n" if !defined($last_ofs);
      die "$0: fatal: FIXUPP not allowed in _BSS" if $last_segment_name eq "_BSS";
      for (my $i = 0; $i < $size; ) {
        die "$0: fatal: EOF in FIXUP header\n" if $i + 3 > $size;
        my ($a, $ofs, $fd) = unpack("CCC", substr($data, $i, 3));
        #print STDERR "info: FIXUPP bytes " . unpack("H*", substr($data, $i, 3)) . "\n";
        #printf STDERR "info: FIXUPP a=0x%x dro=0x%x fd=0x%x\n", $a, $ofs, $fd;
        $i += 3;
        die "$0: fatal: THREAD subrecord not supported\n" if !($a & 0x80);
        die "$0: fatal: frame thread not supported\n" if $fd & 0x80;
        die "$0: fatal: target thread not supported\n" if $fd & 8;
        my $is_self = ~($a >> 6) & 1;
        my $ltype = ($a >> 2) & 15;
        my $lsize = $ltype == 1 ? 2 : undef;
        die "$0: fatal: unsupported FIXUPP location type: $ltype\n" if !defined($lsize);
        my $ltypem = $is_self ? -$ltype : $ltype;
        $ofs = $last_ofs + ($ofs | ($a & 3) << 8);
        my $endofs = $ofs + $lsize;
        die "$0: fatal: FIXUPP data record offset too large\n" if
            $endofs > length($ledata{$last_segment_name});
        my $frame = ($fd >> 4) & 7;
        my $target = $fd & 7;
        my $fixuppr = $fixupp{$last_segment_name};
        die "$0: fatal: FIXUPP must not overlap\n" if @$fixuppr and $fixuppr->[-1][0] > $ofs;
        my $symbol;
        if ($frame == 5 and $target == 6) {
          die "$0: fatal: EOF in FIXUPP target\n" if $i >= $size;
          my $extdef_idx = vec($data, $i++, 8);
          if ($extdef_idx >= 0x80) {
            die "$0: fatal: EOF in FIXUPP target 2-byte extdef_idx\n" if $i >= $size;
            $extdef_idx = ($extdef_idx - 0x80) << 8 | vec($data, $i++, 8);
          }
          die "$0: fatal: FIXUPP EXTDEF index is 0\n" if $extdef_idx == 0;
          die "$0: fatal: unknown FIXUPP EXTDEF index: $extdef_idx\n" if $extdef_idx >= @extdef;
          $symbol = $extdef[$extdef_idx];
          #print STDERR "info: FIXUPP 16-bit $is_self \@$ofs EXTDEF $symbol\n";
        } elsif ($frame == 1 and $target == 4) {
          # We usually get it for string literals in CONST.
          die "$0: fatal: EOF in FIXUPP target\n" if $i + 2 > $size;
          my $segment_idx = vec($data, $i + 1, 8);
          $i += 2;
          die "$0: fatal: unknown segment: $segment_idx\n" if $segment_idx >= @segment_names;
          my $segment_name = $segment_names[$segment_idx];
          #print STDERR "info: FIXUPP 16-bit $is_self \@$ofs SEGMENT $segment_name\n";
          $symbol = "OBJ_SEGMENT_${segment_name}_start";
        } else {
          die "$0: fatal: unsupported FIXUPP: frame=$frame target=$target\n";
        }
        push @$fixuppr, [$endofs, $ofs, $ltypem, $symbol];
      }
    } elsif ($type == 0x9d) {  # Long FIXUPP.
      die "$0: fatal: long FIXUPP not supported\n";
    } elsif ($type == 0x80) {  # THEADR.
    } elsif ($type == 0x88) {  # COMENT.
    } elsif ($type == 0x9a) {  # GRPDEF.
    } else {
      # We do not need to support common symbols, wcc never generates them.
      die sprintf("%s: fatal: unsupported obj record type: type=0x%x size=%d\n", $0, $type, $size);
    }
    $last_segment_name = $last_ofs = undef if $type != 0xa0 and $type != 0xa1 and $type != 0x9c;
  }

  for my $segment_name (@SEGMENT_ORDER) {
    my $size = $segment_name eq "_BSS" ? 0 : $segment_sizes{$segment_name};
    die "$0: fatal: segment size mismatch for $segment_name\n" if
        length($ledata{$segment_name}) != $size;
  }

  my %undefined_symbols = map { $_ => 1 } @extdef;
  delete $undefined_symbols{$extdef[0]};
  for my $symbol (keys %symbol_ofs) {
    delete $undefined_symbols{$symbol};
  }
  delete $undefined_symbols{__argc};
  delete $undefined_symbols{_cstart_};
  die "$0: fatal: missing symbol: _small_code_\n" if !exists($undefined_symbols{_small_code_});
  delete $undefined_symbols{_small_code_};
  my @undefined_symbols = sort keys %undefined_symbols;
  die "$0: fatal: undefined symbols: @undefined_symbols\n" if @undefined_symbols;

  my $entry_count = (defined($symbol_ofs{main_}) + defined($symbol_ofs{_main0_}));
  die "$0: fatal: too many entry points (main functions)\n" if $entry_count > 1;
  die "$0: fatal: missing entry point (main function)\n" if $entry_count == 0;

  sub emit_nasm_segment($) {
    my $segment_name = $_[0];
    my $size = $segment_sizes{$segment_name};
    print "OBJ_SEGMENT_${segment_name}_start:\n";
    print "OBJ_SEGMENT_${segment_name}_size equ $size\n";

    # Sort by ofs ascending.
    my @symbols = sort { $a->[0] <=> $b->[0] or $a->[1] cmp $b->[1] } @{$segment_symbols{$segment_name}};
    my $fixupr = $fixupp{$segment_name};  # Already sorted.
    my $fi = 0; my $si = 0; my $i = 0;
    my $is_bss = $segment_name eq "_BSS";
    my $data = $ledata{$segment_name};
    my $chunk_sub = $segment_name eq "_BSS" ? sub { my $size = $_[0] - $i; print "resb $size\n"; $i = $_[0]; } : sub {
      my $j = $_[0];
      while ($fi < @$fixupr and $fixupr->[$fi][1] < $j) {  # Apply fixup.
        my($endofs, $ofs, $ltypem, $symbol) = @{$fixupr->[$fi++]};
        my $line = unpack("H*", substr($data, $i, $ofs - $i)); $line =~ s@(..)(?=.)@$1, 0x@sg; print "db 0x$line\n";
        my $base = sprintf("0x%x", unpack("v", substr($data, $ofs, 2)));
        my $size = $endofs - $ofs;
        my $rel = $ltypem < 0 ? "-(\$+$size)" : "";
        print "$ASM_DATA_OP{$size} $base+$symbol$rel\n";
        $i = $endofs;
      }
      my $line = unpack("H*", substr($data, $i, $j - $i)); $line =~ s@(..)(?=.)@$1, 0x@sg; print "db 0x$line\n";
      $i = $j;
    };
    while ($si < @symbols) {
      my $j = $symbols[$si][0];
      if ($j > $size or $j < $i) {
        print "$symbols[$si][1] equ $j+OBJ_SEGMENT_${segment_name}_start\n";
        ++$si; next
      }
      $chunk_sub->($j) if $j > $i;
      for (; $si < @symbols and $symbols[$si][0] == $j; ++$si) {
        print "$symbols[$si][1]:\n";
      }
    }
    $chunk_sub->($size) if $size > $i;
  }

  sub emit_nasm() {
    my($fullprog_code, $fullprog_data, $fullprog_bss, $fullprog_end);
    # No need to disambiguate NASM symbols like code_end, because
    # wcc adds _ prefix or suffix to all symbols (including static ones).
    if ($EXT eq "exe") {
# Based on https://github.com/pts/pts-nasm-fullprog/blob/master/fullprog_dosexe.inc.nasm
$fullprog_code = q(
section .text align=1 vstart=-0x10
; DOS .exe header, similar to: https://stackoverflow.com/q/14246493/97248
exe_header:
db 0x4d, 0x5a  ; MZ Signature.
dw ((code_end-exe_header)+(data_end-data_start))&511  ; Image size low 9 bits.
dw ((code_end-exe_header)+(data_end-data_start)+511)>>9  ; Image size high bits, including header and relocations (none here), excluding .bss, rounded up.
dw 0  ; Relocation count.
dw 1  ; Paragraph (16 byte) count of header. Points to code_startseg.
dw (bss_end-bss_start+15-(-((data_end-data_start)+(code_end-code_startseg))&15))>>4  ; Paragraph count of minimum required memory.
dw 0xffff  ; Paragraph count of maximum required memory.
dw (code_end-code_startseg)>>4  ; Stack segment (ss) base, will be same as ds. Low 4 bits are in vstart= of .data.
code_startseg:
dw (bss_end-bss_start)+(data_end-data_start) ; Stack pointer (sp).
dw 0  ; No file checksum.
dw code_start-code_startseg  ; Instruction pointer (ip): 8.
dw 0  ; Code segment (cs) base.
; We reuse the final 4 bytes of the .exe header (dw relocation_table_ofs,
; overlay_number) for code.
code_start:
db 0x16  ; push ss
db 0x1f  ; pop ds
);
$fullprog_data = q(
code_end:
; Fails with `error: TIMES value -... is negative` if code is too large (>~64 KiB).
times -((code_end-code_startseg)>>16) db 0
section .data align=1 vstart=((code_end-code_startseg)&15)
data_start:
);
$fullprog_bss = q(
data_end:
section .bss align=1  ; vstart=0
bss_start:
);
$fullprog_end = q(
auto_stack:  ; Autodetect stack size to fill data segment to 65535 bytes.
%define stack_size (65535-((auto_stack-bss_start)+(data_end-data_start)))
times (stack_size-10)>>256 resb 0  ; Assert that stack size is at least 10.
stack: resb stack_size
bss_end:
; Fails with `error: TIMES value -... is negative` if data is too large (>~64 KiB).
times -(((bss_end-bss_start)+(data_end-data_start))>>16) db 0
);
    } elsif ($EXT eq "com") {
# Based on https://github.com/pts/pts-nasm-fullprog/blob/master/fullprog_dosexe.inc.nasm
$fullprog_code = q(
section .text align=1 vstart=0x100  ; org 0x100
code_start:
);
$fullprog_data = q(
code_end:
; Fails with `error: TIMES value -... is negative` if code is too large (>~64 KiB).
times -((code_end-code_start+0x100)>>16) db 0
section .data align=1 vstart=0x100+(code_end-code_start)  ; vfollows=.text is off by 2 bytes.
data_start:
);
$fullprog_bss = q(
data_end:
section .bss align=1  ; vstart=0
bss_start:
);
$fullprog_end = q(
auto_stack:  ; Autodetect stack size to fill main segment to almost 65535 bytes.
%define stack_size (65535-3-((auto_stack-bss_start)+(data_end-data_start)+(code_end-code_start+0x100)))
times (stack_size-10)>>256 resb 0  ; Assert that stack size is at least 10.
; This is fake, end of stack depends on DOS, typically sp==0xfffe or sp==0xfffc.
stack: resb stack_size
bss_end:
call__fullprog_end:  ; Make fullprog_code without fullprog_end fail.
; Fails with `error: TIMES value -... is negative` if data is too large (>~64 KiB).
; +3 because some DOS systems set sp to 0xfffc instead of 0xffff
; (http://www.fysnet.net/yourhelp.htm).
times -(((bss_end-bss_start)+(data_end-data_start)+(code_end-code_start+0x100)+3)>>16) db 0
);
    } else {
      die "$0: fatal: unknown EXT: $EXT\n";
    }
    print qq(bits 16\ncpu $NASMCPU\n);
    print qq($fullprog_code\n);
    print qq(cld\npush es\npush ds\npop es\nmov di, bss_start\nmov cx, (stack-bss_start+1)>>1\nxor ax, ax\nrep stosw\npop es\n);

    if (defined($symbol_ofs{main_})) {  # TODO(pts): Keep these consistent with emit_executable.
      # `xor dx, dx` sets argv to NULL. ax is already 0 (for argc).
      # OpenWatcom wcc does not support non-constant initializers, so we can call
      # main now.
      print "xor dx, dx\ncall main_\nmov ah, 0x4c  ; EXIT, exit code in al\nint 0x21\n";
    } elsif (defined($symbol_ofs{_main0_})) {
      print qq(db 0xE8\ndw 0x0000+_main0_-\(\$+2\)  ; call _main0_\nmov ah, 0x4c  ; EXIT, exit code in al\nint 0x21\n);
    }
    emit_nasm_segment("_TEXT");
    print qq($fullprog_data\n);
    emit_nasm_segment("CONST");  # String literals.
    emit_nasm_segment("CONST2");  # Other global consts.
    emit_nasm_segment("_DATA");
    print qq($fullprog_bss\n);
    emit_nasm_segment("_BSS");
    print qq($fullprog_end\n);
  }

  sub emit_executable() {
    my $exe_header = "";
    my $vofs = 0;
    if ($EXT eq "exe") {
      $exe_header = pack("a24", "");  # Affected by fixups below.
      $exe_header .= "\x16\x1F";  # push ss; pop ds
      $vofs += length($exe_header) - 16;
    } else {
      $vofs = 0x100;
    }
    # qq(cld\npush es\npush ds\npop es\nmov di, bss_start\nmov cx, (stack-bss_start+1)>>1\nxor ax, ax\nrep stosw\npop es\n);
    my $clear_bss = pack("a5va1va5", "\xFC\x06\x1E\x07\xBF", 0, "\xB9", 0, "\x31\xC0\xF3\xAB\x07");  # Affected by fixups below.
    my %segment_vofs;
    $segment_vofs{clear_bss} = $vofs;
    $segment_vofs{call_main} = $vofs += length($clear_bss);
    # $call_main is affected by fixups below.
    my($call_main, $call_main_symbol, $call_main_ofs);
    if (defined($symbol_ofs{main_})) {
      # `xor dx, dx` sets argv to NULL. ax is already 0 (for argc).
      # OpenWatcom wcc does not support non-constant initializers, so we can call
      # main now.
      # "xor dx, dx\ncall main_\nmov ah, 0x4c  ; EXIT, exit code in al\nint 0x21\n";
      $call_main = pack("a3va4", "\x31\xD2\xE8", 0, "\xB4\x4C\xCD\x21");
      $call_main_symbol = "main_"; $call_main_ofs = 3;
    } elsif (defined($symbol_ofs{_main0_})) {
      # qq(db 0xE8\ndw 0x0000+_main0_-\(\$+2\)  ; call _main0_\nmov ah, 0x4c  ; EXIT, exit code in al\nint 0x21\n);
      $call_main = pack("ava4", "\xE8", 0, "\xB4\x4C\xCD\x21");
      $call_main_symbol = "_main0_"; $call_main_ofs = 1;
    }
    $segment_vofs{_TEXT} = $vofs += length($call_main);
    $vofs += length($ledata{_TEXT});
    my $after_text_vofs = $vofs;
    $vofs &= 15 if $EXT eq "exe";
    my $dgroup_vofs = $segment_vofs{CONST} = $vofs;
    $segment_vofs{CONST2} = $vofs += length($ledata{CONST});
    $segment_vofs{_DATA} = $vofs += length($ledata{CONST2});
    $segment_vofs{_BSS} = $vofs += length($ledata{_DATA});
    $vofs += $segment_sizes{_BSS};
    my %symbol_vofs;  # $symbol => $vofs + $obj_ofs.
    for my $segment_name (keys %segment_symbols) {
      my $this_segment_vofs = $segment_vofs{$segment_name};
      $symbol_vofs{"OBJ_SEGMENT_${segment_name}_start"} = $this_segment_vofs;
      for my $pair (@{$segment_symbols{$segment_name}}) {
        my($ofs, $symbol) = @$pair;
        $symbol_vofs{$symbol} = $this_segment_vofs + $ofs;
      }
    }
    my $data_size = $segment_sizes{CONST} + $segment_sizes{CONST2} + $segment_sizes{_DATA};
    die "$0: fatal: data too large\n" if $data_size + $segment_sizes{_BSS} > 65535;  # !! Allow 65536, also in nasm.
    die "$0: fatal: code too large\n" if $after_text_vofs > 65535;  # !! Allow 65536, also in nasm.
    die "$0: fatal: code+data too large for .com\n" if $EXT ne "exe" and $vofs > 65535;
    my $stack_size = 65535 - ($data_size + $segment_sizes{_BSS} + ($EXT eq "exe" ? 0 : 3 + $after_text_vofs));
    die "$0: fatal: stack too small (code and data too large)\n" if $stack_size < 10;
    if ($EXT eq "exe") {
      my $image_size = length($exe_header) + length($clear_bss) + length($call_main) + $segment_sizes{_TEXT} + $data_size;
      substr($exe_header, 0, 24) = pack("a2v11", "MZ", $image_size & 511, ($image_size + 511) >> 9, 0, 1,
          ($segment_sizes{_BSS} + $stack_size + 15-(-($data_size + $after_text_vofs) & 15)) >> 4,
          0xffff, $after_text_vofs >> 4, $data_size + $segment_sizes{_BSS} + $stack_size, 0, 8, 0);
    }
    substr($clear_bss, 5, 2) = pack("v", $segment_vofs{_BSS});
    substr($clear_bss, 8, 2) = pack("v", ($vofs - $segment_vofs{_BSS}) >> 1);
    substr($call_main, $call_main_ofs, 2) = pack("v", $symbol_vofs{$call_main_symbol} - ($call_main_ofs + 2 + $segment_vofs{call_main}));
    print $exe_header;
    print $clear_bss;
    print $call_main;
    for my $segment_name (@SEGMENT_ORDER) {
      my $data = $ledata{$segment_name};
      my $this_segment_vofs = $segment_vofs{$segment_name};
      for my $fixup (@{$fixupp{$segment_name}}) {  # Apply fixups.
        my($endofs, $ofs, $ltypem, $symbol) = @$fixup;
        die "$0: assert: bad endofs in fixup\n" if $endofs > length($data);
        die "$0: assert: unknown symbol in fixup: $symbol\n" if !defined($symbol_vofs{$symbol});
        my $svofs = $symbol_vofs{$symbol} + unpack("v", substr($data, $ofs, 2));
        $svofs -= $endofs + $this_segment_vofs if $ltypem < 0;
        substr($data, $ofs, 2) = pack("v", $svofs);
      }
      print $data;
    }
  }

  $is_nasm ? emit_nasm() : emit_executable()
'
export LINKER_CODE

test "$Q" || set -x  # echo commands run.

# Corresponding `wcc: owcc' flags:
# -v: lack of -q
# -bdos: -bt=dos
# -ms: -mcomodel=s (default)
# -i=... : -I...
# -s: -fno-stack-check
# -os: -Os  TODO(pts): Should we do -om -oi -ol (from -ox) as well?
# -0: -march=i86
# -W: ??
# ??: -W
# -w4: -Wall
# -wx: -Wextra
# -we: -Werror
# -wcd=202: -Wcd=202 ??
# -D...: -D...
# (default to generate obj, do not link): -c
# -fo=...: -o ...
# -fr: ?? Set error filename.
# -pl: -E
# No need to set $WATCOM or to extend $PATH.
# 202: symbol defined but not referenced (useful for static functions).
if ! "$MYDIR"/ow2bin/wcc $Q $PLL -bt=dos -ms -i="$MYDIR" -s -os -W -w4 -wx -we -wcd=202 "$CPUF" -fr "$@"; then
  test "$Q" || set +x  # Don't echo commands run anymore.
  echo "$0: fatal: wcc failed" >&2
  exit 2
fi
if test "$PL" = -ce; then
  if ! perl -e 'eval $ENV{LINKER_CODE}; die $@ if $@' -- "$EXT" "$NASMCPU" 0 <"$SRCBASE.tmp.obj" >"$EXEOUT"; then
    test "$Q" || set +x  # Don't echo commands run anymore.
    echo "$0: fatal: obj2executable failed" >&2
    exit 4
  fi
elif test "$PL" = -cn; then
  #if ! "$MYDIR"/ow2bin/wdis -a -fi -i=@ "$SRCBASE.tmp.obj" >"$SRCBASE.tmp.wasm"; then die...; fi
  if ! perl -e 'eval $ENV{LINKER_CODE}; die $@ if $@' -- "$EXT" "$NASMCPU" 1 <"$SRCBASE.tmp.obj" >"$SRCBASE.tmp.nasm"; then
    test "$Q" || set +x  # Don't echo commands run anymore.
    echo "$0: fatal: obj2nasm failed" >&2
    exit 4
  fi
  if ! nasm -f bin -I "$MYDIR" -o "$EXEOUT" "$SRCBASE.tmp.nasm"; then
    test "$Q" || set +x  # Don't echo commands run anymore.
    echo "$0: fatal: nasm failed" >&2
    exit 5
  fi
fi
test "$Q" || set +x  # Don't echo commands run anymore.
# : ndisasm -b 16 -e 24 -o 8 "$SRCBASE.exe" >"$SRCBASE.ndisasm"
# : ndisasm -b 16 -o 0x100 "$SRCBASE.com" >"$SRCBASE.ndisasm"

: "$0" OK.
